#!/bin/bash

set -eu

: "${PROJECT_NAME:=$(gcloud config get-value core/project)}"
: "${CLUSTER_REGION:=$(gcloud config get-value compute/region)}"
: "${CLUSTER_ZONE:=$(gcloud config get-value compute/zone)}"
: "${CLUSTER_VERSION:=latest}"
: "${MACHINE_TYPE:=n1-standard-2}"

: "${CF_SYSTEM_DOMAIN:=scf.suse.dev}"
: "${CF_NAMESPACE:=scf}"

# currently this combo works; others are not working. See respective issues.
export CFOPERATOR_TAG=${CFOPERATOR_TAG:-v0.4.1-60.g642832d0}
export SCF_RELEASE_FILE=${SCF_RELEASE_FILE:-scf-3.0.0-8f7a71d1.tgz}

# helm-manager can put its state into this project, not its own
export HELM_MGR_STATE_ROOT=state/helm

# helm-manager sets up TLS for tiller; so use `--tls` for all helm commands
export HELM_TLS_VERIFY=true

export kpack_version=${KPACK_VERSION:-0.0.4}
export kpack_release_url=${KPACK_RELEASE_URL:-"https://github.com/pivotal/kpack/releases/download/v${kpack_version}/release-${kpack_version}.yaml"}
# https://github.com/knative/serving/tree/master/third_party
export knative_istio_version=${ISTIO_VERSION:-1.3.0}
# https://github.com/knative/serving/releases
export knative_version=${KNATIVE_VERSION:-0.9.0}

# Install latest from CI/S3 bucket by default
export scf_release_url=${SCF_RELEASE_URL:-}
# Also can use SCF_RELEASE_FILE=scf-3.0.0-8f7a71d1.tgz for file from bucket

_cluster_name() {
  echo "${CLUSTER_NAME:="$(whoami)-dev"}"
}

usage() {
    echo "Bootstrap GKE and subsystems:"
    echo "  up [--helm|--tiller] -- deploys secure Helm"
    echo "     [--cf|--eirini]   -- deploys Cloud Foundry/Eirini"
    echo "     [--cf-operator]   -- deploys only CF Operator"
    echo "     [--kpack]         -- deploys kpack to build images with buildpacks"
    echo "     [--tekton]        -- deploys Tekton CD"
    echo "     [--knative]       -- deploys Knative Serving/Eventing/Istio"
    echo "     [--knative-addr-name name] -- map GCP address to ingress gateway"
    echo "     [--kubeapp]               -- deploys Kubeapps"
    echo "     [--service-catalog|--sc]  -- deploys Helm/Service Catalog"
    echo "     [--cf-broker]     -- deploys Helm/Service Catalog/Cloud Foundry Service Broker"
    echo "  describe                      -- describes GKE cluster"
    echo "  down                          -- destroys GKE cluster"
}

down() {
  [[ "${CREDHUB_BASE_PATH:-X}" != "X" ]] && {
    echo "Deleting values from Credhub ${CREDHUB_BASE_PATH}..."
    set +e
    credhub delete -n "${CREDHUB_BASE_PATH}/gke-project-name"
    credhub delete -n "${CREDHUB_BASE_PATH}/gke-cluster-name"
    credhub delete -n "${CREDHUB_BASE_PATH}/gke-cluster-zone"
    credhub delete -n "${CREDHUB_BASE_PATH}/gke-cluster-region"
    credhub delete -n "${CREDHUB_BASE_PATH}/helm-ca"
    credhub delete -n "${CREDHUB_BASE_PATH}/helm-tiller-cert"
    credhub delete -n "${CREDHUB_BASE_PATH}/helm-tiller-key"
    set -e
  }
  gcloud container clusters delete "$(_cluster_name)" --region "$CLUSTER_ZONE" --quiet
}

describe() {
  gcloud container clusters describe "$(_cluster_name)" --region "$CLUSTER_ZONE"
}

up() {
  errors=
  [[ "$(command -v gcloud)X" == "X" ]] && { echo "ERROR: missing 'gcloud' CLI from \$PATH"; errors=1; }
  [[ "$(command -v kubectl)X" == "X" ]] && { echo "ERROR: missing 'kubectl' CLI from \$PATH"; errors=1; }
  [[ "${helm:-}" == "1" && "$(command -v helm-manager)X" == "X" ]] && { echo "ERROR: missing 'helm-manager' CLI; fetch git submodules to get vendor/helm-tiller-manager/bin folder"; errors=1; }
  [[ "${scf:-}" == "1" && "$(command -v aws)X" == "X" ]] && { echo "ERROR: missing 'aws' CLI so we can look up latest scf release from S3 bucket"; errors=1; }
  [[ "${cf_broker:-}" == "1" ]] && {
    : "${CF_API:?required for --cf-broker}"
    : "${CF_USERNAME:?required for --cf-broker}"
    : "${CF_PASSWORD:?required for --cf-broker}"
    : "${CF_ORGANIZATION:?required for --cf-broker}"
    : "${CF_SPACE:?required for --cf-broker}"
  }
  # [[ "${knative:-}" == "1" && "$(which knctl)X" == "X" ]] && { echo "ERROR: missing 'knctl' CLI from \$PATH"; errors=1; }
  [[ "$errors" == "1" ]] && { exit 1; }

  [[ "${cf_broker:-}" == "1" ]] && {
    echo "Testing login to Cloud Foundry ${CF_API}..."
    cf api "${CF_API}"
    cf auth "${CF_USERNAME}" "${CF_PASSWORD}"
    cf target -o "${CF_ORGANIZATION}" -s "${CF_SPACE}"
  }

  [[ "${CREDHUB_BASE_PATH:-X}" != "X" ]] && {
    echo "Testing access to Credhub ${CREDHUB_BASE_PATH}..."
    credhub find -n "${CREDHUB_BASE_PATH}" > /dev/null
  }

  gcloud container clusters describe "$(_cluster_name)" --region "$CLUSTER_ZONE" 2>&1 > /dev/null || {
    echo "Creating GKE cluster..."
    additional_flags=
    [[ "${cfcontainers:-}" == "1" ]] && {
      echo "- Using UBUNTU image-type for cf-containers/eirini requirements"
      # https://github.com/SUSE/scf/wiki/Deployment-on-Google-GKE
      additional_flags="${additional_flags} --image-type UBUNTU"
      # TODO -  additional_flags="${additional_flags} --addons=HttpLoadBalancing"
      # see https://cloud.google.com/sdk/gcloud/reference/container/clusters/create
      additional_flags="${additional_flags} --no-enable-autorepair" # not supported for UBUNTU
      additional_flags="${additional_flags} --no-enable-autoupgrade" # not supported for UBUNTU
    }
    gcloud container clusters create "$(_cluster_name)" \
      --region="$CLUSTER_ZONE" \
      --cluster-version="${CLUSTER_VERSION}" \
      --machine-type="${MACHINE_TYPE}" \
      --enable-autoscaling --min-nodes=1 --max-nodes=5 \
      --enable-autorepair \
      --scopes=service-control,service-management,compute-rw,storage-ro,cloud-platform,logging-write,monitoring-write,pubsub,datastore \
      --num-nodes=3 \
      --no-enable-basic-auth \
      --no-issue-client-certificate \
      --enable-ip-alias \
      --metadata disable-legacy-endpoints=true \
      ${additional_flags}

    kubectl create clusterrolebinding cluster-admin-binding \
      --clusterrole=cluster-admin \
      --user="$(gcloud config get-value core/account)"

    [[ "${cfcontainers:-}" == "1" ]] && {
      echo "- Update nodes to support cgroup swap accounting..."
      instance_names=$(gcloud compute instances list --filter="name~$(_cluster_name)" --format json | jq --raw-output '.[].name')
      echo "$instance_names" | xargs -I {} gcloud compute ssh {} -- "sudo sed -i 's/GRUB_CMDLINE_LINUX_DEFAULT=\"console=ttyS0 net.ifnames=0\"/GRUB_CMDLINE_LINUX_DEFAULT=\"console=ttyS0 net.ifnames=0 swapaccount=1\"/g' /etc/default/grub.d/50-cloudimg-settings.cfg"
      # Update grub
      echo "$instance_names" | xargs -I {} gcloud compute ssh {} -- "sudo update-grub"
      # Restart VMs
      echo "$instance_names" | xargs gcloud compute instances reset
    }

    [[ "${CREDHUB_BASE_PATH:-X}" != "X" ]] && {
      echo "Storing cluster into credhub ${CREDHUB_BASE_PATH}..."
      credhub set -n "${CREDHUB_BASE_PATH}/gke-project-name"   -t value -v "$PROJECT_NAME"
      credhub set -n "${CREDHUB_BASE_PATH}/gke-cluster-name"   -t value -v "$(_cluster_name)"
      credhub set -n "${CREDHUB_BASE_PATH}/gke-cluster-zone"   -t value -v "$CLUSTER_ZONE"
      credhub set -n "${CREDHUB_BASE_PATH}/gke-cluster-region" -t value -v "$CLUSTER_REGION"
    }
  }
  gcloud container clusters get-credentials "$(_cluster_name)" --region "$CLUSTER_ZONE" --project "$PROJECT_NAME"

  [[ "${helm:-}" == "1" ]] && {
    echo "Install/upgrade Tiller Server for Helm"
    helm-manager up
    helm repo update
    [[ "${CREDHUB_BASE_PATH:-X}" != "X" ]] && {
      echo "Storing helm into credhub ${CREDHUB_BASE_PATH}..."
      [[ -f $(helm home)/ca.pem ]] && {
        credhub set -n "${CREDHUB_BASE_PATH}/helm-ca" -t value -v "$(cat "$(helm home)/ca.pem")"
        credhub set -n "${CREDHUB_BASE_PATH}/helm-tiller-cert" -t value -v "$(cat "$(helm home)/cert.pem")"
        credhub set -n "${CREDHUB_BASE_PATH}/helm-tiller-key" -t value -v "$(cat "$(helm home)/key.pem")"
      }
    }
  }
  [[ "${servicecatalog:-}" == "1" ]] && {
    echo "Install/upgrade Service Catalog via Helm"
    helm repo add svc-cat https://svc-catalog-charts.storage.googleapis.com
    helm upgrade --install catalog svc-cat/catalog --namespace catalog --wait
  }
  [[ "${cf_broker:-}" == "1" ]] && {
    echo "Install/upgrade CF Marketplace Service Broker via Helm"
    helm repo add starkandwayne https://helm.starkandwayne.com
    helm repo update
    helm upgrade --install --namespace catalog pws-broker starkandwayne/cf-marketplace-servicebroker --wait \
      --set "cf.api=$CF_API" \
      --set "cf.username=${CF_USERNAME:?required},cf.password=${CF_PASSWORD:?required}" \
      --set "cf.organizationGUID=$(jq -r .OrganizationFields.GUID ~/.cf/config.json)" \
      --set "cf.spaceGUID=$(jq -r .SpaceFields.GUID ~/.cf/config.json)"

    # TODO: move into a kubectl apply -f <(echo "--- {}")
    set +e
    kubectl create secret generic pws-broker-cf-marketplace-servicebroker-basic-auth \
      --from-literal username=broker \
      --from-literal password=broker
    set -e

    sleep 5
    svcat register pws-broker-cf-marketplace-servicebroker \
      --url http://pws-broker-cf-marketplace-servicebroker.catalog.svc.cluster.local:8080 \
      --scope cluster \
      --basic-secret pws-broker-cf-marketplace-servicebroker-basic-auth
  }

  [[ "${kpack:-}" == "1" ]] && {
    echo "Install kpack v${kpack_version}"
    kubectl apply -f "$kpack_release_url"
    echo "Installing resources from resources/kpack/*.yaml"
    ls resources/kpack/*.yaml | xargs -L1 kubectl apply -f
  }

  [[ "${cfoperator:-}" == "1" ]] && {
    echo "Install Cloud Foundry/Quarks (cf-operator)"
    [[ -d vendor/cf-operator/deploy/helm/cf-operator ]] || {
      git submodules update --init
    }
    (
      cd vendor/cf-operator
      rm -f helm/*tgz
      bin/build-helm
    )
    cf_operator_helm_tgz=$(ls vendor/cf-operator/helm/cf-operator*tgz)
    # hardcoded at moment for current vendor/cf-operator submodule version
    # : "${CFOPERATOR_TAG:=$(curl -sS 'https://registry.hub.docker.com/v2/repositories/cfcontainerization/cf-operator/tags/' | jq -r ".results[].name" | grep "^v0." | head -n1)}"
    echo "--> Using cfcontainerization/cf-operator:${CFOPERATOR_TAG}"
    echo "    From $(curl -sS 'https://registry.hub.docker.com/v2/repositories/cfcontainerization/cf-operator/tags/' | jq -r --arg tag "$CFOPERATOR_TAG" '.results | map(select(.name == $tag))[].last_updated // "not recently"')"
    helm upgrade --install --wait --namespace "${CF_NAMESPACE}" \
      cf-operator \
      "${cf_operator_helm_tgz}" \
      ${CFOPERATOR_TAG:+--set "image.tag=${CFOPERATOR_TAG}"} \
      --set "provider=gke" \
      --set "operator-webhook-use-service-reference=true" # coming

    # echo "--> Testing cf-operator with example nats deployment"
    # kubectl apply -n "$CF_NAMESPACE" -f vendor/cf-operator/docs/examples/bosh-deployment/boshdeployment-with-custom-variable.yaml
    # sleep 5 # TODO: wait for boshdeployment state change
    # kubectl get pods -n "$CF_NAMESPACE"
  }

  [[ "${cfeirini:-}" == "1" ]] && {
    echo "Install Cloud Foundry/Eirini (scf) for ${CF_SYSTEM_DOMAIN}"
    [[ "${scf_release_url:-X}" == "X" ]] && {
      scf_release_file=${SCF_RELEASE_FILE:-$(aws s3 ls s3://scf-v3/ | sort -nr | head -n1 | awk '{print $4}')}
      scf_release_date=$(aws s3 ls s3://scf-v3/ | grep "$scf_release_file" | awk '{print $1}')
      echo "--> Using ${scf_release_file}${scf_release_date:+ from ${scf_release_date}}"
      scf_release_url="https://scf-v3.s3.amazonaws.com/${scf_release_file}"
    }
    helm upgrade --install --wait --namespace ${CF_NAMESPACE} \
      scf \
      "$scf_release_url" \
      --set "system_domain=${CF_SYSTEM_DOMAIN}" \
      --set "features.eirini=true"

    echo "Upgrade buildpacks"
    kubectl apply -n scf -f https://raw.githubusercontent.com/starkandwayne/update-all-cf-buildpacks/master/k8s-update-forever.yaml
  }

  [[ "${tekton:-}" == "1" ]] && {
    echo "Install tekton"
    kubectl apply --filename https://storage.googleapis.com/tekton-releases/latest/release.yaml
    echo "Installing resources from resources/tekton/*.yaml"
    ls resources/tekton/*.yaml | xargs -L1 kubectl apply -f
  }

  [[ "${knative:-}" == "1" ]] && {
    echo "Install/upgrade Knative without monitoring"
    echo "---> install istio ${knative_istio_version}"
    kubectl apply --wait=true \
      --filename "https://raw.githubusercontent.com/knative/serving/master/third_party/istio-${knative_istio_version}/istio-crds.yaml"
    kubectl apply --wait=true \
      --filename "https://raw.githubusercontent.com/knative/serving/master/third_party/istio-${knative_istio_version}/istio-lean.yaml"
    echo "---> wait for istio pilot to start"
    kubectl wait -l app=pilot pod --for condition=Ready -n istio-system --timeout 5m
    # while [[ $(kubectl get pods -n istio-system -l app=pilot -o 'jsonpath={..status.conditions[?(@.type=="Ready")].status}') != "True" ]]; do echo "waiting for pod" && sleep 1; done
    echo "---> install knative serving/eventing CRDs"
    # TODO https://github.com/knative/serving/issues/5722
    kubectl apply --wait=true \
      --selector knative.dev/crd-install=true \
      --filename "https://github.com/knative/serving/releases/download/v${knative_version}/serving.yaml" \
      --filename "https://github.com/knative/eventing/releases/download/v${knative_version}/release.yaml" || \
    kubectl apply --wait=true \
      --selector knative.dev/crd-install=true \
      --filename "https://github.com/knative/serving/releases/download/v${knative_version}/serving.yaml" \
      --filename "https://github.com/knative/eventing/releases/download/v${knative_version}/release.yaml"

    echo "---> install knative serving/eventing"
    kubectl apply --wait=true \
      --filename "https://github.com/knative/serving/releases/download/v${knative_version}/serving.yaml" \
      --filename "https://github.com/knative/eventing/releases/download/v${knative_version}/release.yaml"
    echo "---> wait for knative to start"
    kubectl wait -l app=controller pod --for condition=Ready -n knative-serving --timeout 30s


    # knctl domain create --default --domain knative.starkandwayne.com

    # echo "Deploy sanity test app to Knative"
    # set +e
    # kubectl create ns bootstrap-test
    # set -e
    # knctl deploy \
    #   --namespace bootstrap-test \
    #   --service hello \
    #   --image gcr.io/knative-samples/helloworld-go \
    #   --env TARGET=Bootstrap

    # podStatus=Init
    # while [[ "${podStatus}" != "Running" ]]; do
    #   sleep 2
    #   podStatus=$(kubectl get pods -n bootstrap-test -l serving.knative.dev/configuration=hello -o jsonpath="{.items[0].status.phase}")
    #   echo "  ${podStatus}"
    # done
    # knctl curl -n bootstrap-test -s hello
  }

  [[ "${knative_addr_name:-X}" != "X" ]] && {
    address=$(gcloud compute addresses describe knative-ingress --region "$CLUSTER_REGION" --format json)
    ip=$(echo "$address" | jq -r ".address")
    echo "Mapping Knative Ingress Gateway to $ip..."
    kubectl patch svc istio-ingressgateway --namespace istio-system --patch \
      "$(echo "$address" | jq -cr "{spec: {loadBalancerIP: .address}}")"

    echo
    echo "In a while, test your DNS + ingress with:"
    echo "  curl -v hello.bootstrap-test.knative.starkandwayne.com"
    echo
  }

  [[ "${kubeapps:-}" == "1" ]] && {
    # TODO: convert to kubectl apply -f <()
    set +e
    kubectl create serviceaccount kubeapps-operator
    kubectl create clusterrolebinding kubeapps-operator --clusterrole=cluster-admin --serviceaccount=default:kubeapps-operator
    set -e

    helm repo add bitnami https://charts.bitnami.com/bitnami
    helm upgrade --install kubeapps bitnami/kubeapps --namespace kubeapps \
      --set tillerProxy.tls.verify=true \
      --set tillerProxy.tls.ca="$(cat "$(helm home)/ca.pem")" \
      --set tillerProxy.tls.key="$(cat "$(helm home)/key.pem")" \
      --set tillerProxy.tls.cert="$(cat "$(helm home)/cert.pem")" \
      --wait

    echo "Use the following token to authenticate:"
    echo "kubectl get secret \$(kubectl get serviceaccount kubeapps-operator -o jsonpath='{.secrets[].name}') -o jsonpath='{.data.token}' | base64 --decode"
  }
}

case "${1:-usage}" in
  up)
    shift
    while [[ $# -gt 0 ]]; do
      case "${1:-}" in
        --cfcontainers)
          export cfcontainers=1
          export helm=1
          ;;
        --cf|--eirini)
          export helm=1
          export cfoperator=1
          export cfeirini=1
          ;;
        --cf-operator)
          export helm=1
          export cfoperator=1
          ;;
        --kpack)
          export kpack=1
          ;;
        --tekton)
          export tekton=1
          ;;
        --knative)
          export knative=1
          ;;
        --knative-addr-name)
          shift
          export knative_addr_name=$1
          ;;
        --helm|--tiller)
          export helm=1
          ;;
        --service-catalog|--sc)
          export helm=1
          export servicecatalog=1
          ;;
        --cf-broker)
          export helm=1
          export servicecatalog=1
          export cf_broker=1
          ;;
        --kubeapps)
          export helm=1
          export kubeapps=1
          ;;
        --credhub-store)
          shift
          export CREDHUB_BASE_PATH=$1
          ;;
      esac
      shift
    done

    up
    ;;

  describe)
    shift
    describe
    ;;

  down)
    shift
    while [[ $# -gt 0 ]]; do
      case "${1:-}" in
        --credhub-store)
          shift
          export CREDHUB_BASE_PATH=$1
          ;;
      esac
      shift
    done
    down
    ;;

  *)
    usage
    exit 1
    ;;
esac
